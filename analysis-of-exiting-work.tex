\chapter{Analysis of existing work}
In this chapter we will discuss and compare the existing fuzzers that focus on fuzzing of web services. More precisely to the existing fuzzer with focus on application level fuzzing since it is the most relevant to us. \label{sub:Types of fuzzers} Moreover, we will try to find their shortcommings that we would like to subsequently improve on in our architecture and implementation.

\section{apiFuzz}
The first fuzzer we will talk about is apiFuzz \cite{apiFuzz2020github}. It fuzzes a single HTTP request. The fuzzer accepts the input in form of \texttt{curl} command. It extracts headers, authentication, query parameters, body, path and url by parsing the \texttt{curl} command line arguments.

It assumes that the request body is in a JSON format and starts the mutation of the individual key and value fields in the JSON body. By mutating also the keys of the JSON payload it breaks the grammar rules for the input. This will cause, that the most of the found bugs will be in the JSON parser code. Locating a bug in the JSON parser code has the advantage that multiple services might be using the same JSON library and therefore there is a high probability that the bug will occur there as well. On the other hand, by breking the grammar rules most request will not pass the JSON parser and therefore will not able to trigger some unexpected behaviour of the application logic. Thus dramatically decreasing the code coverage.

We may say that apiFuzz is a smart fuzzer as it is able to determine the structure as well as the types of input data from the parsed \texttt{curl} command line arguments. However, it is limited by the data provided by the \texttt{curl} command. For instance when the endpoint is able to accept Additional JSON fields that were not included in the \texttt{curl} command, the apiFuzz will not fuzz them.

Finally, the apiFuzz is not aware of the internal structure of the fuzzed program. As a result, it is able to fuzz targets without having the access to the target's source code or even a binary. Additionaly, since apiFuzz fuzzes a single request to single endpoint it is improbable to change the state of the web service. For instance, if it would fuzz one endpoint that creates some object and anotherone that retrieves the object it may, the result of the second request might be affected by the first one. The combination of statelessness with black-box technique makes the paralelization trivial and apiFuzz takes advantage of it.

\section{TnT-Fuzz}
The next fuzzer we will describe is TnT-Fuzz \cite{tntFuzzer2020github}. One could think of  TnT-Fuzz as an apiFuzz scaled up. While apiFuzz fuzzes single endpoint, TnT-Fuzz fuzzes all of them. Moreover, it automates the exploration of different endpoints by parsing the OpenAPI specification. From the specification it also gets the correct input types as well as where in the request they should be placed. For example, in request headers, body od \texttt{url} query parameters.

Nevertheless, slight difference from apiFuzz can be seen when it comes to input creation. TnT-Fuzz will create the payload in a two steps. First, it will generate random input of correct type. Then, if the request body is in JSON format, it will mutate the input too. Tnt-Fuzz uses PyJFuzz fuzzing framework for fuzzing JSON inputs \cite{pyjfuzz2020github}. A worth to mention fact is that apiFuzz uses the PyJFuzz fuzzing framework as well. Hence we can forsee that TnT-Fuzz will behave rather equivalently as apiFuzz. It as well augments the JSON keys and therefore fuzzes the JSON parser rather that the business logic of the web service. Moreover, the grammar rules are broken one more time - when the input type is JSON object, which is most of the cases. Then TnT-Fuzz will not parse the whole structure of the JSON object but generate a random one instead.

Unfortunately, when we were trying to test the TnT-Fuzz we came across several issues. The first one is that it takes the OpenAPI specification from the \texttt{url} of the web service (e.g. \texttt{http://localhost:2999/api/swagger.json}), however, some services like HashiCorp Vault \cite{vault2020github} provide the specification for authorized users only. This obstacle can be circumvent by supplying an API token for authorization, nevertheless, that means that TnT-Fuzz will running as authorized user during the whole fuzzing session, which might not be desired. Next issue we came across was during fuzzing self-hosted git service \cite{gitea2020web}. TnT-Fuzz was not able to parse the specification and raised an exception.

At last, let us have a look at error reporting. TnT-Fuzz will log every request that is described in the OpenAPI specification by printing it to a terminal in table format. In the table user can find the endpoint to which the request was send, HTTP status code, response body as well as the request in a \texttt{curl} format. User than may subsequently resend the request and analyze the bug in more detail, for example by inspecting the web service logs. However, if a web service does not document the API properly in the specification, for instance by not including status codes signaling client errors (\texttt{404 - Not Found} is most common), it will cluter the logs with numerous false positive findings.


\section{RESTler}
\label{sec:restler}
The last fuzzer we will take a look at is called RESTler developed by Microsoft Research team \cite{atlidakis2019restler}. As the RESTler's research paper states, the main asset of RESTler is statefullness. Moreover, it claims to be the first statefull REST API fuzzer. Before we proceed with exploration of its numerous features, let us look into what statefullness means in context of API fuzzers.

Nearly every service holds some state, mainly in form of database. Making a request to the API may change the state. For example, \texttt{POST} request will create and \texttt{PUT} request will update an item in the database. Knowing whether an item exists is crutial if the most  efficient usage of resources is desired. Request that queryies an item that yet was not created is essentially useless. The API will most probably response with status code signaling user error - \texttt{Not Found}. This kind of request only wasted the valuable resources.

To minimize meaningless request RESTler infers producer-consumer dependencies among request types. e.g sending request \texttt{A} makes sense only if request \texttt{B} was sent before. RESTler is able to infer those dependencies by examining swagger specification (OpenAPI v2) of fuzzed service. Then it performs a breadth-first search to create a valid sequence of requests with satisfied dependencies. The successful request is denoted by receiving HTTP status code in 200 range. When the sequence is not successful - status code in range 400 is received, RESTler will not add that request to the sequence chain. However, requests frequently take some input. The input might be in form of a request body, \texttt{url} query parameters, headers or cookies. Therefore response from a sigle endpoint differs when we send a different input to it. To solve this issue RESTler maintains a \textit{fuzzing dictionary}. \textit{Fuzzing dictionary} typically consists of sample values for every fuzzable type. For instance, string type values may have include \texttt{""} (empty string) or \texttt{"somestring"}. Integer types, on the other hand, may include \texttt{0} and \texttt{1}. However, RESTler needs to keep the aforementioned \textit{fuzzing dictionary} rather small since with the size of the dictionary the the complexity of graph increases as well. One notable disadvantage of the \texttt{BFS} strategy is the lack of randomness that is caused by small dictionary size.

In addition to \texttt{BFS} strategy, Microsoft Research team incorporated random walk strategy to the RESTler as well. This strategy has loosed requirements on the choice of requests. RESTler still makes the dynamic analysis of requirements for each request. Meaning that it will add a request to a request sequence only when all dependencies are satisfied. Nevertheless, it will not send them and check the response code to verify that the request sequence is indeed valid.

Microsoft Research team tested RESTler on several APIs. One of those was purposely made \textit{Blog Post Service} with a subtle bug regading checksum verification. The bug was trigered when user used \texttt{GET} method to obtain a blog (and its checksum) and then supplied the checksum (along with other parameters) via \texttt{PUT} method to update the blog. Thanks to the inspection of producer-consumer dependencies between those endpoints RESTler was able to trigger it. Moreover, thanks to the \texttt{BFS} strategy, RESTler was able to achieve larger code coverage. If the correct checksum was not supplied, the code path when blog is updated would have never run.

In addition to the \textit{Blog Post Service}, Microsoft Research team fuzzed with RESTler GitLab as well. GitLab is a git hosting platform for collaboration. Microsoft Research team fuzzed several resources including commits, branches, issues, repos, groups and projects and compared the \texttt{BFS} to the random walk strategy. The results of the comparison are quiet interesting. The \texttt{BFS} fuzzing strategy will produce significantly less requests that signal user error, mainly error \texttt{404 - Not Found}. However, when comparing achieved code coverage overe time, both strategies yielded similar results. Surprisingly, random walk strategy obtained better result in certian REST resources.

As for the error reporting, RESTler works similar to the apiFuzz. It logs a bug if a \texttt{500 HTTP} status code - \texttt{Internal Server Error} is received. Nonetheless, RESTler is able to repla the results. i.e. when bug is found, RESTler will recurse backwards and log the whole request sequence that lead to the bug.

\paragraph{}
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c c c|}
\hline
                              & apiFuzz    & TnT-Fuzz   & RESTler    \\
\hline
aware of internal structure   & black-box  & black-box  & black-box  \\
aware of input data structure & semi-smart & semi-smart & smart      \\
input generation technique    & mutation   & combined   & generation \\
statefullness                 & stateless  & stateless  & statefull  \\
automates API exploration     & no         & yes        & yes        \\
\hline
\end{tabular}
\caption{Comparison of fuzzers focused on fuzzing web services}
\label{table:fuzzers-comparison}
\end{center}
\end{table}

As we are able to see, API fuzzers have numerous similarities. One of which we have not mentioned yet is a language of implementation. All above-mentioned fuzzer are implemented in \texttt{Python} programing language. \texttt{Python} is a high-level multiparadigm dynamic scipting language. Due to its dynamic nature \texttt{Python} comes especially useful when generating random and unstructured data. Moreover, \texttt{Python} offers a large variety of community-developed modules, for instance \texttt{requests} module including \texttt{HTTP} client for sending requests.

\paragraph{}
As we can see in table \ref{table:fuzzers-comparison} every discussed fuzzer was using a back-box fuzzing technique. The prelevance of this technique is understandable as their frequent goal is reusability. Moreover, it is rather difficult to monitor a binary without having an access to it, which might by the case of the web services. We may also observe that more advanced fuzzers like RESTler and TnT-Fuzz are using and automation techniques to inspect the API and find the endpoint that they will subsequently fuzz.

To conclude this chapter, we may say that the field of API fuzzers is not as widely researched as the field of fuzzing binaries, which gives us an interesting opportunity to explore it and find out new facts and interconnections.
