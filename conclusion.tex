\chapter{Conclusion}
In this chapter we will present the possiblites of our fuzzer.

\section{Future work}
We explored the possiblily of fuzzing an API with help of OpenAPI specification and created a fuzzer that uses the specification in an unique. However, the potential of utilizing OpenAPI specification when fuzzing APIs is not used up at all. In following paragraphs we will dicsuss some additional work that could be done to improve the fuzzer.

\subsection{Checking authorization}
As we dicsussed in a chapter regarding the OpenAPI specification (section \ref{sec:openapi}) we stated that OpenAPI specification allow the APIs to mark which endpoints are authorized. We could use this knowledge in a fuzzing. The fuzzer running an unauthorized session could be sending requests to those endpoints and when it would receive any other response that \texttt{401 - Unauthorized} the fuzzer would mark it as a finding. Thanks to this technique we would be able find those bugs and to strenghten the security of APIs even more by not letting unauthorized user retrieve any information.

\subsection{Expanding randomization}
There is a lot of things we can further randomize. As for now, we always send all possible parameters, headers, cookies or other types of inputs. We deem that by sending every possible form of input the fuzzer will achieve higher code coverage. Nonetheless, it would be interesting not to send all possible inputs and examine how would the APIs handle these types of situations. Moreover, some parts of the requests are marked in the specification as required. We could try not sending them as well an inspect the behaviour of the API.

\subsubsection{Randomizing HTTP methods}
When we were talking about randomizing input we wanted only to augment it. Mostly by breaking the specification and not sending some parts. Nevertheless, we can try to send something that the APIs do not expect too. While sending the random data to the API would we ineffective since it would not test the underlying logic but rather the input parser, sending requests with different HTTP methods might be worth a while. We may ask ourselfs, why it is the case? There is only a handfull of HTTP methods so trying all od them will not take a long time. Furthermore, when API responds with anything other that HTTP status code \texttt{405 - Method Not Allowed} it is an indication that the API is listening on that endpoint (with specified method). This knowledge, can be then subsequently used to examine the endpoint and potentially expoit it. Actually, Teddy Katz was able to bypass GitHub's OAuth flow by sending a request to an endpoint with undocumented HTTP method \cite{kartz2019bypass}. This functionality would make it possible to locate the vunlerability automatically without time-demanding decompilation of source code.


\section{Closing thoughts}
% use as spec verification
